2章 プログラムの意味
------------
## この章の概要
プログラムはただの文字の羅列ではなくプログラマのその当時の思考のアイデアのスナップショットである。  
コードを意味あるものにするための仕組みをRubyで簡単な言語を実装しながら学んでいく。

## 2.1 「意味」の意味
プログラム言語を記述するためには「構文(プログラムがどう見えるか)」と「意味論(プログラムが何を意味するか)」が必要。  
記述アプローチとしては3つのパターンがある

### 実装による仕様
実際に動くコンパイラやインタプリタが仕様になっている。別実装を作る場合、「リファレンス実装の振る舞いを忠実にまねる」という作業が求められる。  
Ruby(MRI)などがこれに当たる。

### 公式文書としての仕様書
C++,Java,ECMAScriptなどがこれに当たる。  
公文書として検討した結果の仕様なので、そこにある仕様は合理的なものである可能性が高いが、仕様書を読むのが大変。

### 数学的テクニックを駆使した仕様書
完全に曖昧さをなくした仕様をつくることができる

## 2.2 構文
構文とはプログラム文字列を有効なプログラムかどうかを判定する規則の集まりである。
構文はパーサによって抽象構文木(AST)に変換される

> 抽象構文木（abstract syntax tree、AST）とは、通常の構文木（具象構文木、あるいはparse treeとも言う）から、言語の意味に関係ない情報を取り除き、意味に関係ある情報のみを取り出した（抽象した）木構造のデータ構造である。
> 理論的には、有限なラベル付き有向木であり、分岐点（internal node）に演算子、葉（leaf node）にそのオペランドを対応させたものである。つまり、葉は変数や定数に対応する。

[抽象構文木 - Wikipedia](http://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A8)

## 2.3 操作的意味論
抽象機械(abstract machine)を使ってある言語が実行されたときの意味を記述する。プログラムの意味を実際の振る舞いに落としこむ。

### スモールステップ意味論
構文を小さなステップ(スモールステップ)で繰り返し簡約(reduce)することによって、プログラムを評価する。

```
(1 * 2) + (3 * 4)
-> 2 + (3 * 4)
-> 2 + 12
-> 14
```

以降、SIMPLEという名の簡単な言語を実装しながらスモールステップの方法で抽象機械を記述する。

#### 式
* 言語の構文になる要素(数値、演算子など)ごとにクラスを定義し、そのインスタンスからなる木として抽象構文木を表現する  
* 式ごとに簡約可能か(reducible?)と簡約可能であれば簡約(reduce)メソッドを持つ  
* 変数を表現するために環境(environment)をHashオブジェクトとして各式のreduceメソッドに渡す
* 抽象機械は簡約可能で無くなるまで式を簡約し続ける

[式クラス](TODO: リンク張る)  
[抽象機械](TODO: リンク張る)

#### 文
* 文は、評価されることで抽象機械の状態を変更する
 * 式は環境を変化させない(pure), 文は環境を変化させる(impure)

[文クラス](TODO: リンク張る)

#### 正当性
SIMPLEはこれまでの実装内容だと「構文的には正しいがプログラム的には正しく無い」場合が存在してしまう。  
```
(例)
x = true; x = x + 1
```
これを防ぐために、静的意味論を使って動作する前にプログラムの正しさをチェックする(9章)

#### 応用
同じ構文でも意味の付け方が変われば言語仕様も変わる。設計者の判断次第。

* SIMPLEは左から式を評価するが、Rubyも同様
* SIMPLEは式と文が明確に分かれているが、Rubyは式と文は同じものである

### ビッグステップ意味論
#### スモールステップとの比較
スモールステップ意味論

* 操作を細かい簡約の組み合わせと反復で最終的な仕様を導く
* 間接的で処理順序が決まっている

ビッグステップ意味論

* 式や文から直接結果を導く方法を記述する
* 式や文が自身の評価方法(evaluate)を知っておりそれを再起的に組み合わせて評価する
* スモールステップに比べ、詳細が欠けている場合がある
 * 通常処理順序が定義されていない、など
  * 今回のRubyの実装に関してはRubyのルール的に順序が一定である

#### 式
式は自分自身が評価されるか、実行後別の式に評価されるかのどちらかしかない

#### 文
文は初期の文と環境を最終的な環境に変換するプロセスを記述する

#### 応用
コールスタックはスモールステップ意味論では構文木の深度が最大値だが、ビッグステップ意味論は再帰により、より深くなる

* スモールステップは各式、文自体が抽象機械に役に立つ中間結果を生成する
* ビッグステップは1度の計算で結果を出すための途中の道順は人、もしくはマシンにおまかせ
* やりたいことによって使い分ける
 * 効率の良い実装を構築する
 * プログラムの特性を証明する
 * 最適化を工夫する
 * etc.

今までの流れで2つのインタプリタを作れた。

* インタプリタを作ることは言語の意味を説明することである。
* 他にも数学的記法でつくることも出来る。

## 2.4 表示的意味論
ある言語を別の表現に変換する。操作的意味論より抽象的なアプローチ。  
例えば英語を日本語に翻訳するのは表示的意味論の領域である。  
  
ここではSIMPLEをRubyに変換することで表示的意味論を学ぶ

### 式
「環境を引数にとり、評価結果の値を返す」というものをRubyでprocを使って表現する

### 文
「評価結果として更新された環境を返す」というものをRubyでHashの更新を行うprocコードで表現する

### 応用
#### ここまで出来た事
* SIMPLEを実行可能なインタプリタをRubyで作った(操作的意味論)
* SIMPLEをRubyコードに変換するコンパイラを作った(表示的意味論)
Rubyコンパイラを作ったことでSIMPLEの言語的特性(環境は式や文に渡されていくものである)という事を明確化できた。  
これらは効率が良いわけではないが、ここから新たに効率よい実装をするときのベースにできる。

## 2.5 実際の形式意味論
### 意味論の理解
形式意味論は結局何に使えるか？

* プログラムの意味に曖昧さのない仕様を与えることができる
* 表示的意味論(コンパイラ)の正当性を操作的意味論(インタプリタ)で証明する
* 表示的意味論は結局プログラム言語のやっている事とほぼ同じ
 * Javaコード -> バイトコード(javac) -> x86インストラクション(JVM) -> マイクロインストラクション(CPU) -> 実行

### その他のスタイル
| 種類                 | 別名                        |
|---------------------|-----------------------------|
| スモールステップ意味論 | 構造的操作的意味論、遷移的意味論 |
| ビッグステップ意味論   | 自然意味論、関係意味論         |
| 表示的意味論          | 不動点意味論、数学的意味論      |

#### 公理的意味論
表明(assertion)を使い、事前条件と事後条件の表明を行う事で文の意味を記述する。  
事前条件と事後条件が正しければプログラム言語の正当性を証明出来る。テスト的なアプローチ。

## 2.6 パーサの実装
今まではRubyの書き方でSIMPLEを実行していたが、SIMPLEソースコードを直接パーサを使って構文木にしたほうが楽。  
Rubyでのパーサの実装は[Treetop](http://cjheath.github.io/treetop/)を使って行うと簡単にできる。  
パーサを直接実装する方法は4章で説明される。